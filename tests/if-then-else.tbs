export function test(a: int32, b:float32): int32 {

    if(a == 1 || b == 0.1){
        return 1;
    }else {
        if(a == 3){
            if(b == 3.32){
                return 5;
            }
        }else{
            return 4;
        }
    }
    return 0;
}
export unsafe function utf16_to_cstring(input: string): *byte {
    if (input as *uint32 == null) {
      return null;
    }

    var utf16_length = *(input as *uint32);
    var utf8_length: uint32 = 0;
    var utf16 = input as *ushort + 2;

    // Measure text
    var i: uint32 = 0;
    while (i < utf16_length) {
      var codePoint: uint32;

      // Decode UTF-16
      var a = *(utf16 + i);
      i = i + 1;
      if (i < utf16_length && a >= 0xD800 && a <= 0xDBFF) {
        var b = *(utf16 + i);
        i = i + 1;
        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00) as uint32;
      } else {
        codePoint = a;
      }

      // Encode UTF-8
      utf8_length = utf8_length + (
        codePoint < 0x80 ? 1 :
        codePoint < 0x800 ? 2 :
        codePoint < 0x10000 ? 3 :
        4) as uint32;
    }

    var utf8 = malloc(utf8_length + 1);
    var next = utf8;

    // Convert text
    i = 0;
    while (i < utf16_length) {
      var codePoint: uint32;

      // Decode UTF-16
      var a = *(utf16 + i);
      i = i + 1;
      if (i < utf16_length && a >= 0xD800 && a <= 0xDBFF) {
        var b = *(utf16 + i);
        i = i + 1;
        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00) as uint32;
      } else {
        codePoint = a;
      }

      // Encode UTF-8
      if (codePoint < 0x80) {
        *next = codePoint as byte;
      } else {
        if (codePoint < 0x800) {
          *next = (((codePoint >> 6) & 0x1F) | 0xC0) as byte;
        } else {
          if (codePoint < 0x10000) {
            *next = (((codePoint >> 12) & 0x0F) | 0xE0) as byte;
          } else {
            *next = (((codePoint >> 18) & 0x07) | 0xF0) as byte;
            next = next + 1;
            *next = (((codePoint >> 12) & 0x3F) | 0x80) as byte;
          }
          next = next + 1;
          *next = (((codePoint >> 6) & 0x3F) | 0x80) as byte;
        }
        next = next + 1;
        *next = ((codePoint & 0x3F) | 0x80) as byte;
      }
      next = next + 1;
    }

    // C strings are null-terminated
    *next = "\\0";

    return utf8;
  }